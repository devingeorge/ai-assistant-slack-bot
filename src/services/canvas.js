// src/services/canvas.js
import { logger } from '../lib/logger.js';

/**
 * Create a Slack Canvas from AI response content using canvases.create API
 * @param {Object} client - Slack client
 * @param {string} channelId - Channel where canvas should be created
 * @param {string} content - AI response content to format into canvas
 * @param {string} title - Title for the canvas
 * @param {string} userQuery - Original user query that generated this response
 * @returns {Promise<Object>} Canvas creation result
 */
export async function createCanvasFromResponse(client, channelId, content, title, userQuery) {
  try {
    logger.info('Creating canvas from AI response:', { channelId, title, contentLength: content.length });

    // Format the content into Canvas document_content
    const documentContent = formatContentForCanvasDocument(content, title, userQuery);

    // Create the canvas using the proper canvases.create API
    // Try without document_content first to see if the API works
    const result = await client.canvases.create({
      title: title || 'AI Response',
      channel_id: channelId
    });

    if (result.ok) {
      // Extract canvas ID from the response
      const canvasId = result.canvas_id || result.canvas?.canvas_id;
      
      logger.info('Canvas created successfully:', { 
        canvasId: canvasId,
        fullResult: result 
      });
      
      if (!canvasId) {
        logger.error('Canvas created but no canvas_id returned:', result);
        return {
          success: false,
          error: 'Canvas created but no ID returned'
        };
      }
      
      // Try to add content to the canvas using canvases.edit
      try {
        const editResult = await client.canvases.edit({
          canvas_id: canvasId,
          changes: [
            {
              operation: 'replace',
              document_content: documentContent
            }
          ]
        });
        
        if (editResult.ok) {
          logger.info('Canvas content added successfully');
        } else {
          logger.warn('Failed to add content to canvas:', editResult.error);
        }
      } catch (editError) {
        logger.warn('Error adding content to canvas:', editError.message);
      }
      
      return {
        success: true,
        canvas: result.canvas,
        canvasId: canvasId,
        url: `https://slack.com/canvas/${canvasId}`
      };
    } else {
      logger.error('Failed to create canvas:', result.error);
      return {
        success: false,
        error: result.error
      };
    }
  } catch (error) {
    logger.error('Error creating canvas:', error);
    return {
      success: false,
      error: error.message
    };
  }
}

/**
 * Format AI response content into Canvas document_content
 * @param {string} content - AI response content
 * @param {string} title - Canvas title
 * @param {string} userQuery - Original user query
 * @returns {Object} Canvas document_content
 */
function formatContentForCanvasDocument(content, title, userQuery) {
  // Try the markdown format that Canvas API expects
  let markdownContent = content;
  
  // Add original question if provided
  if (userQuery && userQuery !== content) {
    markdownContent = `**Original Request:**\n${userQuery}\n\n---\n\n${content}\n\n---\n\n*Generated by Grok AI • ${new Date().toLocaleString()}*`;
  } else {
    markdownContent = `${content}\n\n---\n\n*Generated by Grok AI • ${new Date().toLocaleString()}*`;
  }

  return {
    type: 'markdown',
    markdown: markdownContent
  };
}

/**
 * Parse content into structured Canvas elements
 * @param {string} content - Content to parse
 * @returns {Array} Canvas elements
 */
function parseContentToCanvasElements(content) {
  const elements = [];

  // Split content into sections based on markdown headers
  const sections = content.split(/(?=^#{1,6}\s)/m).filter(section => section.trim());

  if (sections.length === 0) {
    // No headers found, treat as plain text
    elements.push({
      type: 'paragraph',
      text: content
    });
    return elements;
  }

  sections.forEach(section => {
    const lines = section.trim().split('\n');
    const firstLine = lines[0];
    
    // Check if first line is a header
    const headerMatch = firstLine.match(/^(#{1,6})\s+(.+)$/);
    
    if (headerMatch) {
      const headerLevel = Math.min(headerMatch[1].length, 3); // Canvas supports h1-h3
      const headerText = headerMatch[2];
      const restOfContent = lines.slice(1).join('\n').trim();

      // Add header element
      elements.push({
        type: 'heading',
        level: headerLevel,
        text: headerText
      });

      // Add content under header
      if (restOfContent) {
        const formattedContent = formatTextContent(restOfContent);
        elements.push({
          type: 'paragraph',
          text: formattedContent
        });
      }
    } else {
      // No header, treat as regular content
      const formattedContent = formatTextContent(section);
      elements.push({
        type: 'paragraph',
        text: formattedContent
      });
    }
  });

  return elements;
}

/**
 * Format text content for Canvas (convert markdown to Slack mrkdwn)
 * @param {string} text - Text to format
 * @returns {string} Formatted text
 */
function formatTextContent(text) {
  return text
    // Convert **bold** to *bold*
    .replace(/\*\*(.*?)\*\*/g, '*$1*')
    // Convert ### headers to bold
    .replace(/^###\s+(.+)$/gm, '*$1*')
    .replace(/^##\s+(.+)$/gm, '*$1*')
    // Convert bullet points
    .replace(/^[-*+]\s+(.+)$/gm, '• $1')
    // Convert numbered lists
    .replace(/^\d+\.\s+(.+)$/gm, (match, content) => {
      const number = match.match(/^\d+/)[0];
      return `${number}. ${content}`;
    })
    // Convert code blocks to code formatting
    .replace(/```([\s\S]*?)```/g, '```$1```')
    // Convert inline code
    .replace(/`([^`]+)`/g, '`$1`')
    // Convert links
    .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<$2|$1>');
}

/**
 * Generate a unique canvas ID
 * @returns {string} Canvas ID
 */
function generateCanvasId() {
  return `canvas_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

/**
 * Create a simple canvas with just text content using canvases.create API
 * @param {Object} client - Slack client
 * @param {string} channelId - Channel ID
 * @param {string} text - Text content
 * @param {string} title - Canvas title
 * @returns {Promise<Object>} Result
 */
export async function createSimpleCanvas(client, channelId, text, title = 'AI Response') {
  const documentContent = {
    type: 'markdown',
    markdown: `${text}\n\n---\n\n*Generated by Grok AI • ${new Date().toLocaleString()}*`
  };

  try {
    const result = await client.canvases.create({
      title: title,
      channel_id: channelId
    });

    if (result.ok) {
      // Extract canvas ID from the response
      const canvasId = result.canvas_id || result.canvas?.canvas_id;
      
      if (!canvasId) {
        logger.error('Canvas created but no canvas_id returned:', result);
        return {
          success: false,
          error: 'Canvas created but no ID returned'
        };
      }
      
      // Try to add content to the canvas using canvases.edit
      try {
        const editResult = await client.canvases.edit({
          canvas_id: canvasId,
          changes: [
            {
              operation: 'replace',
              document_content: documentContent
            }
          ]
        });
        
        if (editResult.ok) {
          logger.info('Canvas content added successfully');
        } else {
          logger.warn('Failed to add content to canvas:', editResult.error);
        }
      } catch (editError) {
        logger.warn('Error adding content to canvas:', editError.message);
      }
      
      return {
        success: true,
        canvas: result.canvas,
        canvasId: canvasId,
        url: `https://slack.com/canvas/${canvasId}`
      };
    } else {
      return {
        success: false,
        error: result.error
      };
    }
  } catch (error) {
    logger.error('Error creating simple canvas:', error);
    return {
      success: false,
      error: error.message
    };
  }
}

/**
 * Detect if user is requesting Canvas creation
 * @param {string} message - User message
 * @returns {boolean} Whether user wants Canvas creation
 */
export function isCanvasCreationRequest(message) {
  const canvasKeywords = [
    'create canvas',
    'make canvas',
    'put this in canvas',
    'canvas please',
    'create a canvas',
    'make a canvas',
    'canvas document',
    'create document',
    'save as canvas',
    'canvas this'
  ];
  
  const lowerMessage = message.toLowerCase();
  return canvasKeywords.some(keyword => lowerMessage.includes(keyword));
}

/**
 * Extract the content for Canvas creation from user message
 * @param {string} message - User message
 * @returns {string} Content to put in Canvas
 */
export function extractCanvasContent(message) {
  // Remove Canvas request keywords
  const canvasKeywords = [
    'create canvas',
    'make canvas',
    'put this in canvas',
    'canvas please',
    'create a canvas',
    'make a canvas',
    'canvas document',
    'create document',
    'save as canvas',
    'canvas this'
  ];
  
  let content = message;
  for (const keyword of canvasKeywords) {
    content = content.replace(new RegExp(keyword, 'gi'), '').trim();
  }
  
  // Clean up connecting words
  content = content.replace(/^(for|about|regarding|on|:|-)+\s*/i, '').trim();
  
  return content;
}
