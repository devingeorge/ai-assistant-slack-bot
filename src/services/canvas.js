// src/services/canvas.js
import { logger } from '../lib/logger.js';

/**
 * Create a Slack Canvas from AI response content
 * @param {Object} client - Slack client
 * @param {string} channelId - Channel where canvas should be created
 * @param {string} content - AI response content to format into canvas
 * @param {string} title - Title for the canvas
 * @param {string} userQuery - Original user query that generated this response
 * @returns {Promise<Object>} Canvas creation result
 */
export async function createCanvasFromResponse(client, channelId, content, title, userQuery) {
  try {
    logger.info('Creating canvas from AI response:', { channelId, title, contentLength: content.length });

    // Format the content into Canvas blocks
    const canvasBlocks = formatContentForCanvas(content, title, userQuery);

    // Create the canvas
    const result = await client.canvas.create({
      canvas: {
        canvas_id: generateCanvasId(),
        blocks: canvasBlocks
      }
    });

    if (result.ok) {
      logger.info('Canvas created successfully:', { canvasId: result.canvas?.canvas_id });
      
      // Share the canvas in the channel
      const shareResult = await client.canvas.share({
        canvas_id: result.canvas.canvas_id,
        channel: channelId
      });

      if (shareResult.ok) {
        logger.info('Canvas shared successfully in channel');
        return {
          success: true,
          canvas: result.canvas,
          share: shareResult
        };
      } else {
        logger.error('Failed to share canvas:', shareResult.error);
        return {
          success: true,
          canvas: result.canvas,
          shareError: shareResult.error
        };
      }
    } else {
      logger.error('Failed to create canvas:', result.error);
      return {
        success: false,
        error: result.error
      };
    }
  } catch (error) {
    logger.error('Error creating canvas:', error);
    return {
      success: false,
      error: error.message
    };
  }
}

/**
 * Format AI response content into Canvas blocks
 * @param {string} content - AI response content
 * @param {string} title - Canvas title
 * @param {string} userQuery - Original user query
 * @returns {Array} Canvas blocks
 */
function formatContentForCanvas(content, title, userQuery) {
  const blocks = [];

  // Header block with title
  blocks.push({
    type: 'header',
    text: {
      type: 'plain_text',
      text: title || 'AI Response'
    }
  });

  // Original query section
  if (userQuery) {
    blocks.push({
      type: 'section',
      text: {
        type: 'mrkdwn',
        text: `*Original Question:*\n${userQuery}`
      }
    });

    blocks.push({
      type: 'divider'
    });
  }

  // Parse and format the content
  const formattedContent = parseContentToBlocks(content);
  blocks.push(...formattedContent);

  // Footer with timestamp
  blocks.push({
    type: 'divider'
  });

  blocks.push({
    type: 'context',
    elements: [
      {
        type: 'mrkdwn',
        text: `Generated by Grok AI • ${new Date().toLocaleString()}`
      }
    ]
  });

  return blocks;
}

/**
 * Parse content into structured Canvas blocks
 * @param {string} content - Content to parse
 * @returns {Array} Canvas blocks
 */
function parseContentToBlocks(content) {
  const blocks = [];

  // Split content into sections based on markdown headers
  const sections = content.split(/(?=^#{1,6}\s)/m).filter(section => section.trim());

  if (sections.length === 0) {
    // No headers found, treat as plain text
    blocks.push({
      type: 'section',
      text: {
        type: 'mrkdwn',
        text: content
      }
    });
    return blocks;
  }

  sections.forEach(section => {
    const lines = section.trim().split('\n');
    const firstLine = lines[0];
    
    // Check if first line is a header
    const headerMatch = firstLine.match(/^(#{1,6})\s+(.+)$/);
    
    if (headerMatch) {
      const headerLevel = headerMatch[1].length;
      const headerText = headerMatch[2];
      const restOfContent = lines.slice(1).join('\n').trim();

      // Add header block
      blocks.push({
        type: 'header',
        text: {
          type: 'plain_text',
          text: headerText
        }
      });

      // Add content under header
      if (restOfContent) {
        const formattedContent = formatTextContent(restOfContent);
        blocks.push({
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: formattedContent
          }
        });
      }
    } else {
      // No header, treat as regular content
      const formattedContent = formatTextContent(section);
      blocks.push({
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: formattedContent
        }
      });
    }

    // Add divider between sections (except for the last one)
    if (sections.indexOf(section) < sections.length - 1) {
      blocks.push({
        type: 'divider'
      });
    }
  });

  return blocks;
}

/**
 * Format text content for Canvas (convert markdown to Slack mrkdwn)
 * @param {string} text - Text to format
 * @returns {string} Formatted text
 */
function formatTextContent(text) {
  return text
    // Convert **bold** to *bold*
    .replace(/\*\*(.*?)\*\*/g, '*$1*')
    // Convert ### headers to bold
    .replace(/^###\s+(.+)$/gm, '*$1*')
    .replace(/^##\s+(.+)$/gm, '*$1*')
    // Convert bullet points
    .replace(/^[-*+]\s+(.+)$/gm, '• $1')
    // Convert numbered lists
    .replace(/^\d+\.\s+(.+)$/gm, (match, content) => {
      const number = match.match(/^\d+/)[0];
      return `${number}. ${content}`;
    })
    // Convert code blocks to code formatting
    .replace(/```([\s\S]*?)```/g, '```$1```')
    // Convert inline code
    .replace(/`([^`]+)`/g, '`$1`')
    // Convert links
    .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<$2|$1>');
}

/**
 * Generate a unique canvas ID
 * @returns {string} Canvas ID
 */
function generateCanvasId() {
  return `canvas_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

/**
 * Create a simple canvas with just text content
 * @param {Object} client - Slack client
 * @param {string} channelId - Channel ID
 * @param {string} text - Text content
 * @param {string} title - Canvas title
 * @returns {Promise<Object>} Result
 */
export async function createSimpleCanvas(client, channelId, text, title = 'AI Response') {
  const blocks = [
    {
      type: 'header',
      text: {
        type: 'plain_text',
        text: title
      }
    },
    {
      type: 'section',
      text: {
        type: 'mrkdwn',
        text: text
      }
    },
    {
      type: 'context',
      elements: [
        {
          type: 'mrkdwn',
          text: `Generated by Grok AI • ${new Date().toLocaleString()}`
        }
      ]
    }
  ];

  try {
    const result = await client.canvas.create({
      canvas: {
        canvas_id: generateCanvasId(),
        blocks: blocks
      }
    });

    if (result.ok) {
      // Share the canvas
      await client.canvas.share({
        canvas_id: result.canvas.canvas_id,
        channel: channelId
      });

      return {
        success: true,
        canvas: result.canvas
      };
    } else {
      return {
        success: false,
        error: result.error
      };
    }
  } catch (error) {
    logger.error('Error creating simple canvas:', error);
    return {
      success: false,
      error: error.message
    };
  }
}
